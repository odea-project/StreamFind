---
title: 'Evaluation of Wastewater Ozonation with Mass Spectrometry'
author:
  name: Ricardo Cunha
  email: cunha@iuta.de
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    fig_caption: true
    toc: true
    number_sections: true
    toc_float: true
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{Evaluation of Wastewater Ozonation with Mass Spectrometry}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Libraries
library(knitr)
library(kableExtra)
library(magrittr)
library(ggplot2)
library(plotly)
library(StreamFind)
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.width = 9, results = "markup", comment = "", message = FALSE, warning = FALSE)
path_wd <- getwd()
```

```{r resources, include=FALSE}
all_files <- StreamFindData::get_ms_file_paths()
files <- all_files[grepl("blank|influent|o3sw", all_files)]
db_all <- StreamFindData::get_ms_tof_spiked_chemicals()
db_all <- db_all[grepl("S", db_all$tag), ]
cols <- c("name", "formula", "mass", "rt", "tag")
db_is <- db_all[db_all$tag %in% "IS", ]
db_is <- db_is[, cols, with = FALSE]
db_is <- db_is[!db_is$name %in% c("Ibuprofen-d3", "Naproxen-d3"), ]
db <- db_all[db_all$tag %in% "S", ]
db <- db[, cols, with = FALSE]
db_with_ms2 <- StreamFindData::get_ms_tof_spiked_chemicals_with_ms2()
db_with_ms2 <- db_with_ms2[db_with_ms2$tag %in% "S", ]
db_with_ms2 <- db_with_ms2[, c("name", "formula", "mass", "SMILES", "rt", "polarity", "fragments"), with = FALSE]
db_with_ms2$polarity[db_with_ms2$polarity == 1] <- "positive"
db_with_ms2$polarity[is.na(db_with_ms2$polarity)] <- "positive"
db_with_ms2$polarity[db_with_ms2$polarity == -1] <- "negative"
```

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

<br>

<br>

***

# Introduction

In this article we demonstrate how StreamFind can be used to evaluate ozonation of secondary wastewater effluent (i.e., 
effluent of the aerated biological treatment) using mass spectrometry (MS). A set of 18 *mzML* files are used, 
representing blank, influent and effluent measurements in triplicate for both positive and negative ionization modes.

```{r files}
basename(files)
```

The showcase will use the StreamFind *MassSpecEngine*, which encapsulates all tools required for parsing, storing, 
processing and visualizing MS data. Note that not all methods/functions will be shown as the demonstration focuses of 
the workflow to assess wastewater ozonation. Other processing methods are available in the StreamFind package and can be
found in the [StreamFind reference documentation](https://odea-project.github.io/StreamFind/reference/index.html).

# *MassSpecEngine*

The [*R6*](https://r6.r-lib.org/) [*MassSpecEngine*](https://odea-project.github.io/StreamFind/reference/MassSpecEngine.html) 
class object is created using the `MassSpecEngine$new()`, as shown below. The argument `analyses` can be used to add 
directly the set of *mzML* files. Note that the original vendor files were converted to *mzML* format using the 
[convert_ms_files()](https://odea-project.github.io/StreamFind/reference/convert_ms_files.html) function, which uses 
the *msConvert* command line from [ProteoWizard](https://proteowizard.sourceforge.io/download.html).

```{r create-ms}
# Creates a MassSpecEngine from mzML files
ms <- MassSpecEngine$new(analyses = files)
```

```{r show-ms}
# Prints in console a summary of the MassSpecEngine
ms
```

# *ProjectHeaders*

Project headers (e.g., name, author and description) can be added to the `MassSpecEngine$headers` by creating an S7 
*ProjectHeaders* class object as shown below. The arguments (i.e. elements) of the *ProjectHeaders* can be anything but
must have length one.

```{r add-headers}
# Adds headers to the MassSpecEngine
ms$headers <- StreamFind::ProjectHeaders(
  name = "Wastewater Ozonation Showcase",
  author = "Ricardo Cunha",
  description = "Demonstration project"
)

# Gets and shows the headers
show(ms$headers)

# Gets the MassSpecEngine date
ms$headers$date
```

# Replicates and blanks

The analysis replicate names and the associated blank replicate name can be amended in the *MassSpecEngine*, as shown 
below. Alternatively, a `data.frame` with column names *file*, *replicate* and *blank* could be added as the `analyses` 
argument in `MassSpecEngine$new(analyses = files)` to have directly the replicate and blank replicate names assigned 
(more details [here](https://odea-project.github.io/StreamFind/reference/MassSpecEngine.html#method-MassSpecEngine-new)).

```{r add-replicates}
# Character vector with analysis replicate names
rpls <- c(
  rep("blank_neg", 3),
  rep("blank_pos", 3),
  rep("influent_neg", 3),
  rep("influent_pos", 3),
  rep("effluent_neg", 3),
  rep("effluent_pos", 3)
)

# Character vector with associated blank replicate names
# Note that the order should match the respective replicate
blks <- c(
  rep("blank_neg", 3),
  rep("blank_pos", 3),
  rep("blank_neg", 3),
  rep("blank_pos", 3),
  rep("blank_neg", 3),
  rep("blank_pos", 3)
)

# Amends replicate and blank names
ms$analyses$replicates <- rpls
ms$analyses$blanks <- blks

# Replicates and blanks were amended
ms$analyses$info[, 1:5]
```

# *ProcessingSettings*

Data processing is performed by steps according to *ProcessingSettings*. S7 *ProcessingSettings* class objects are 
obtained via the respective [`[Engine type]Settings_[module name]_[algorithm name]`](https://odea-project.github.io/StreamFind/reference/index.html#processing-settings-for-ms-data) 
constructor functions, attributing the respective subclass. Below we obtain the *ProcessingSettings* for the step 
`FindFeatures` using the algorithm *openms*. The parameters for each processing module can be changed via the 
constructor arguments. Documentation for each *ProcessingSettings* subclass can be found in the 
[StreamFind reference documentation](https://odea-project.github.io/StreamFind/reference/index.html).

```{r ffs}
# Gets ProcessingSettings for finding features using the openms algorithm
ffs <- MassSpecSettings_FindFeatures_openms(
  noiseThrInt = 1000,
  chromSNR = 3,
  chromFWHM = 7,
  mzPPM = 15,
  reEstimateMTSD = TRUE,
  traceTermCriterion = "sample_rate",
  traceTermOutliers = 5,
  minSampleRate = 1,
  minTraceLength = 4,
  maxTraceLength = 70,
  widthFiltering = "fixed",
  minFWHM = 4,
  maxFWHM = 35,
  traceSNRFiltering = TRUE,
  localRTRange = 0,
  localMZRange = 0,
  isotopeFilteringModel = "none",
  MZScoring13C = FALSE,
  useSmoothedInts = FALSE,
  intSearchRTWindow = 3,
  useFFMIntensities = FALSE,
  verbose = FALSE
)

# Prints in console the details of the ProcessingSettings
show(ffs)
```

```{r other-settings}
# Creates a Workflow object with all processing steps for the MS data
workflow <- StreamFind::Workflow(
  list(
    
    # Find features using the openms algorithm, created above
    ffs,
    
    # Annotation of natural isotopes and adducts
    MassSpecSettings_AnnotateFeatures_StreamFind(
      rtWindowAlignment = 0.3,
      maxIsotopes = 8,
      maxCharge = 2,
      maxGaps = 1
    ),
    
    # Excludes annotated isotopes and adducts
    MassSpecSettings_FilterFeatures_StreamFind(
      excludeIsotopes = TRUE,
      excludeAdducts = TRUE
    ),
    
    # Grouping features across analyses
    MassSpecSettings_GroupFeatures_openms(
      rtalign = FALSE,
      QT = FALSE,
      maxAlignRT = 5,
      maxAlignMZ = 0.008,
      maxGroupRT = 5,
      maxGroupMZ = 0.008,
      verbose = FALSE
    ),
    
    # Filter feature groups with maximum intensity below 5000 counts
    MassSpecSettings_FilterFeatures_StreamFind(
      minIntensity = 5000
    ),
    
    # Fill features with missing data
    # Reduces false negatives
    MassSpecSettings_FillFeatures_StreamFind(
      withinReplicate = FALSE,
      rtExpand = 2,
      mzExpand = 0.0005,
      minTracesIntensity = 1000,
      minNumberTraces = 6,
      baseCut = 0.3,
      minSignalToNoiseRatio = 3,
      minGaussianFit = 0.2
    ),
    
    # Calculate quality metrics for each feature
    MassSpecSettings_CalculateFeaturesQuality_StreamFind(
      filtered = FALSE,
      rtExpand = 2,
      mzExpand = 0.0005,
      minTracesIntensity = 1000,
      minNumberTraces = 6,
      baseCut = 0
    ),
    
    # Filter features based on minimum signal-to-noise ratio (s/n)
    # The s/n is calculated using the CalculateFeaturesQuality method
    MassSpecSettings_FilterFeatures_StreamFind(
      minSnRatio = 5
    ),
    
    # Filter features using other parameters via the patRoon package
    MassSpecSettings_FilterFeatures_patRoon(
      maxReplicateIntRSD = 40,
      blankThreshold = 5,
      absMinReplicateAbundance = 3
    ),
    
    # Finds internal standards in the MS data
    # db_is is a data.table with the
    # name, mass and expected retention time of 
    # spiked internal standards, as shown below
    MassSpecSettings_FindInternalStandards_StreamFind(
      database = db_is,
      ppm = 8,
      sec = 10
    ),
    
    # Loads MS1 for features not filtered
    MassSpecSettings_LoadFeaturesMS1_StreamFind(
      filtered = FALSE
    ),
    
    # Loads MS2 for features not filtered
    MassSpecSettings_LoadFeaturesMS2_StreamFind(
      filtered = FALSE
    ),
    
    # Loads feature extracted ion chromatograms (EIC)
    MassSpecSettings_LoadFeaturesEIC_StreamFind(
      filtered = FALSE
    ),
    
    # Performs suspect screening using the StreamFind algorithm
    # db_with_ms2 is a database with suspect chemical standards
    # includes MS2 data (i.e., fragmentation pattern) from standards
    MassSpecSettings_SuspectScreening_StreamFind(
      database = db_with_ms2,
      ppm = 10,
      sec = 15,
      ppmMS2 = 10,
      minFragments = 3
    )
  )
)

show(workflow)

# Accessing and printing the 7th ProcessingSettings object from the workflow
# show(workflow[[7]])
```

Then, the *Workflow* object can be added to the *MassSpecEngine*. Note that the order will matter when the workflow 
is applied!

```{r add-settings}
# Adds the workflow to the engine. The order matters!
ms$workflow <- workflow

# Printing the data processing workflow
ms$print_workflow()
```

# `run_workflow()`

The *Workflow* can be applied by `run_workflow()`, as demonstrated below. Note that with `run_workflow()`, the 
processing modules are applied with the same order as they were added.

```{r do-workflow, results='hide'}
# Runs all ProcessingSettings added
ms$run_workflow()
```

# Results

The created features and feature groups can be inspected as `data.table` objects or plotted by dedicated methods in the 
*MassSpecEngine*. Internally, the *MassSpecEngine* stores the results in the *NTS* object, which can be accessed with
`MassSpecEngine$nts`. Yet, the engine interface is recommended for accessing the results. However, the *NTS* object can
be used for more advanced operations, such as exporting the results to a database or other formats or use the native 
objects from other packages (e.g., patRoon) as we demonstrated further in this article.

## `data.table` objects

The features and feature groups can be obtained as `data.table` with the `MassSpecEngine$get_features()` and 
`MassSpecEngine$get_groups()` methods. The methods also allow to look for specific features/feature groups using mass, 
mass-to-charge ratio, retention time and drift time targets, as show below for a small set of compound targets where 
mass and retention time expected values are known. Note that drift time is only applicable for MS data with ion mobility 
separation.

```{r database-show}
db
```

```{r show-target-groups}
# Compounds are searched by monoisotopic mass and retention time
# ppm and sec set the mass (im ppm) and time (in seconds) allowed deviation, respectively
# average applies a mean to the intensities in each analysis replicate group
ms$get_groups(mass = db, ppm = 10, sec = 15, average = TRUE)
```

Already by inspection of the `data.table`, it is possible to see compounds detected in the influent but not in the 
effluent (e.g., Carbamazepine) or compounds that are appear to be reduced during ozonation (e.g., Metoprolol). Since 
positive and negative ionization mode were combined, there are compounds that appear in both polarities and are grouped 
by neutral monoisotopic mass (e.g., Candesartan and Diclofenac).

## `plot_groups` methods

For a better overview of the results, the method `MassSpecEngine$plot_groups()` or even more detailed the method 
`MassSpecEngine$plot_groups_overview()` can be used.

```{r plot-groups}
# set legendNames to TRUE for using the names in db as legend
ms$plot_groups(mass = db, ppm = 10, sec = 15, legendNames = TRUE)
```

```{r plot-groups-overview, fig.height=10}
ms$plot_groups_overview(mass = db, ppm = 5, sec = 10, legendNames = TRUE)
```

## Filtered not removed

The *FilterFeatures* method was applied to filter features according to defined conditions/thresholds. Yet, the filtered 
features were not removed but just tagged as filtered. For instance, when the method `MassSpecEngine$get_groups()` is 
run with `filtered` argument set to `TRUE`, the filtered features are also shown. Below, we search for the same 
compounds as above but with the `filtered` argument set to `TRUE`. Potential features from Valsartan are now returned 
but were filtered due to low intensity. Note that when extracting features based on basic parameters, i.e. mass and time,
does not mean that features are identified. The identification of features is a more complex process and requires
additional information, such as MS/MS data as in the processing method suspect screening.

```{r show-filtered-is}
# Set filtered to TRUE for showing filtered features/feature groups
ms$get_groups(mass = db, ppm = 5, sec = 10, average = TRUE, filtered = TRUE)
```

## Internal Stanards

The method *FindInternalStandards* was applied for tagging spiked internal standards and the results can be obtained 
with the dedicated method `MassSpecEngine$get_internal_standards()` or plotted as a quality overview using the method 
`MassSpecEngine$plot_internal_standards()`, as shown below. The plot gives an overview of the mass, retention time and 
intensity variance of the internal standards across the analyses in the project.

```{r database-is-show}
# List of spiked internal standards
db_is
```

```{r}
# Gets the internal standards evaluation data.table
ms$get_internal_standards()
```

```{r plot_is_qc, fig.height=10, fig.cap="Quality control of spiked internal standards"}
ms$plot_internal_standards()
```

## Components

The method *AnnotateFeatures* was applied to annotate the natural isotopes and adducts into components. Implementation 
of annotation for in-source fragments is planned but not yet available with the StreamFind algorithm. The method 
`MassSpecEngine$get_components()` can be used to search for components, as shown below for the analysis number 11. 
Because the filters `excludeIsotopes` and `minIntensity` were applied, the isotopic features are likely filtered.

```{r show-components}
# Components of Diclofenac and Candesartan in analysis 11
ms$get_components(
  analyses = 11,
  mass = db[db$name %in% c("Diclofenac", "Candesartan"), ],
  ppm = 5, sec = 10
)
```

The components (i.e., isotopes and adducts) can also be visualized with the method `MassSpecEngine$map_components()`, 
as shown below for the internal standards added to analysis 11. Note that again the `filtered` argument was set to 
`TRUE` to return also filtered features, as the internal standards were likely excluded by blank subtraction.

```{r plot-components, fig.cap="Components (i.e., isotopes and adducts) of internal standards in analysis 11"}
ms$map_components(
  analyses = 11,
  mass = db_is,
  ppm = 8, sec = 10,
  filtered = TRUE,
  legendNames = TRUE
)
```

## Suspects

The methods `MassSpecEngine$get_suspects()` and `MassSpecEngine$plot_suspects()` can be used to inspect the suspect 
screening results. In the plot function, a second plot is added to compare the experimental fragmentation pattern (top) 
with the fragmentation pattern of the respective reference standard (down) added within the database. The `colorBy` 
argument can be set to *targets+replicates* to legend the plot with combined keys of suspect target names and analysis 
replicate names.

```{r}
ms$get_suspects()
```

```{r plot-suspects}
ms$plot_suspects(colorBy = "targets+replicates")
```

# Methods from patRoon

The NTS object holds the original objects from the [patRoon](https://github.com/rickhelmus/patRoon) package, which can 
be accessed directly. For instance, the S4 class `features` or `featureGroups` objects are can be accessed via the *NTS*
object with `ms$nts$features`. The `patRoon` package provides a set of functions for the native objects and can be 
applied the `ms$nts$features` object, as shown below. See more information in the 
[patRoon reference documentation](https://rickhelmus.github.io/patRoon/reference/index.html).

```{r}
# Native patRoon object
ms$nts$features
```

```{r}
# Using the native patRoon's plotUpSet method
patRoon::plotUpSet(ms$nts$features)
```

# More to come

Future integration:

- Correcting matrix for better comparison between influent and effluent
- Annotation of in-source fragments
- Screening of transformation products using the *biotransformer* tool via patRoon
- Fold-change and other statistic analysis for inter-sample correlation

***
