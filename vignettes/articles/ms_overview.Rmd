---
title: "streamFind for mass spectrometry with R"
output:
  bookdown::html_document2:
    fig_caption: true
    toc: true
    number_sections: true
    toc_float: true
    toc_depth: 4
vignette: >
  %\VignetteEncoding{UTF-8}
  %\VignetteIndexEntry{streamFind for mass spectrometry with R}
  %\VignetteEngine{knitr::rmarkdown}
editor_options:
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  fig.align = "center",
  fig.width = 8,
  results = 'markup',
  cache = TRUE,
  size = 'small'
)
options(width = 110)
```

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

```{r libraries, include=FALSE}
library(knitr)
library(kableExtra)
library(magrittr)
library(mzR)
library(patRoon)
library(streamFind)
```

# Introduction

The streamFind R package is a framework for data processing in environmental and quality studies. This article introduces the basic framework of the streamFind R package for mass spectrometric (MS) data processing. Installation instructions of streamFind R package can be found [here](https://github.com/ricardobachertdacunha/streamFind). Once installed, the streamFind R package is loaded as shown below.

```{r setup, eval=FALSE}
library(streamFind)
```

# Resources

The streamFind includes example data files via the supplementary  [streamFindData](https://github.com/ricardobachertdacunha/streamFindData) R package.

```{r install-streamFindData, eval=FALSE}
# install the streamFindData R package from the GitHub repository
remotes::install_github("ricardobachertdacunha/streamFindData")
```

## MS files

Once [streamFindData](https://github.com/ricardobachertdacunha/streamFindData) is installed, the full file paths of example MS data files can be obtained as shown below. The files available are described in the table below. Note, the MS files (.mzML and .mzXML) were trimmed with the function `trim_ms_files_spectra()` from streamFind to reduce their size. The centroided Agilent Q-TOF files were trimmed with retention time between 900 and 1350 seconds, *m/z* for MS1 data between 200 and 450 Da and *m/z* for MS2 between 35 and 450 Da. Additionally, MS1 and MS2 traces below 100 and 50 counts were removed, respectively. The profile Agilent Q-TOF files were trimmed with retention time between 1000 and 1200 seconds, *m/z* for MS1 data between 200 and 300 Da and *m/z* for MS2 between 35 and 300 Da. Additionally, MS1 and MS2 traces below 1 count were removed to exclude empty spectra. The files are used within the document for demonstration of the framework.

```{r resource-files, cache=FALSE}
files <- streamFindData::msFilePaths()
# files is a vector with all file full paths
```

<br>

```{r description-files, echo=FALSE}
df_files_desc <- streamFindData::msFilesDescription()

knitr::kable(df_files_desc, caption = "Files included in the streamFind R package.") %>%
  column_spec(column = 3, width = "100px") %>%
  column_spec(column = 4, width = "60px") %>%
  kable_styling(font_size = 11.5, bootstrap_options = c("striped", "hover", "responsive"), fixed_thead = TRUE) %>%
  scroll_box(width = "100%", height = "600px")
```

<br>

## Spiked chemicals

The chemicals spiked in the MS files are described below in the table. The internal standards (IS) are spiked to all Agilent Q-TOF files. The chemical standards (S) were only spiked for the first 6 Agilent Q-TOF files. Note that not all IS and S are visible in the profile Agilent Q-TOF files as a narrower trimming was applied.

```{r load-table-chemicals}
db <- streamFindData::msSpikedChemicals()
```

<br>

```{r show-table-chemicals, echo=FALSE}
cols_table_01 <- c("name", "CAS", "formula", "mass", "rt", "ionization", "tag", "in_file")
knitr::kable(db[, cols_table_01, with = FALSE], caption = "Chemical standards spiked.") %>%
  kable_styling(font_size = 11, bootstrap_options = c("striped", "hover", "responsive"), fixed_thead = TRUE) %>%
  scroll_box(width = "100%", height = "600px")
```

<br>

# MassSpecData

The MassSpecData is an [R6 class](https://r6.r-lib.org/articles/Introduction.html) object, holding the MS data parsed from *.mzML* or *.mzXML* files as well as the methods to get, visualize and process the parsed data (see `?MassSpecData` for detailed documentation). The most straight forward manner to initiate a MassSpecData object is with a character vector of *.mzML* or *.mzXML* file full path/s, as shown below for three MS files (triplicate, 1 to 3 in files table in section [MS files](#ms-files)). The object name was defined to *Example 1* using the argument *headers*. For more information on the `MassSpecData$new()` method, see `?MassSpecData` documentation.

```{r new-ms-object-call, results='hide', warning=FALSE}
ms <- MassSpecData$new(files = files[1:3], headers = list(name = "Example 1"))
```

The `print` (or `show`) method is shown below by running the MassSpecData object name. A list of the included analyses is printed to the console matching the files added.

```{r print-method}
ms
```

Another option to obtain an overview of the `ms` object is the method `get_overview()` as shown below, returning a data.frame with the analysis details within the MassSpecData object.

```{r get-overview}
ms$get_overview()[, 1:5] # only the first 5 columns
```

## Internal fields

The MassSpecData object contains the following internal fields (or private fields) to store standardized data: **headers**, **settings**, **analyses**, **groups** and **alignment**. The internal fields cannot be directly accessed nor changed. Instead, the user must use the respective get and add methods, as shown in the sections [get methods](#get-methods) and [add methods](#add-methods), respectively. The add methods contain validation and conformity checks to ensure that the structure and semantics of added data are respected.

- The **headers** is also a Headers S3 class object and list with flexible headers of length one (e.g., name, path, date, etc.) that characterize the MassSpecData object. When not given, *name*, *path* and *date* are automatically generated (*name* is set to `NA_character_`, *path* is set to `getwd()` and *date* is set to `Sys.time()`) and included in the list, as they are required for workflow purposes. Other entries can be added by the user without type (or class) limitations but should be uniquely named and of length one. See `?Headers` for more information;
- The **settings** is a named `list` of ProcessingSettings S3 class objects used for data processing (see `?settings` for more information). Each added settings object is named according to the function call (or processing name). The settings interface is described in section [processing settings](#processing-settings);
- The **analyses** is a named `list` of MassSpecAnalysis S3 class objects representing each file added to the MassSpecData (see` ?MassSpecAnalysis` for more information). The name of each MassSpecAnalysis object in the analyses list is the name of the file (without extension). No duplicate file names (or analyses names) can exist in the MassSpecData. The structure of the MassSpecAnalysis S3 class object is described in section [analyses](#analyses); 
- The **groups** is a `data.table` with the feature groups after correspondence analysis (i.e., grouping of features across analyses). More information about **groups** is given in section [groups](#groups);
- The **alignment** is a `list` with the results of the retention time alignment for each analyses in the MassSpecData object. More information about **alignment** is given in section [alignment](#alignment).

## Get methods

Several methods are implemented to access data within the MassSpecData object, as already demonstrated for the `get_overview()`. A method is always used by writing the name of the MassSpecData object followed by a `$` and then the method call (e.g., `ms$get_overview()`). The internal fields can be accessed with `get_headers()`, `get_settings()`, `get_analyses()`, `get_groups()` and `get_alignment()`. For instance, the get method for the headers returns the list of entries. Note that the `path` and `date` were automatically created when the vignette was built even if not given is the headers argument when the MassSpecData object is created.

```{r get-headers}
ms$get_headers()
```

Similarly, the get method for analyses returns the list of MassSpecAnalysis objects. Below the `get_analyses()` is used to get the first analysis object (`a1`). Then, the `names()` function is used to show the names of entries in the `a1` MassSpecAnalysis, which represents the first *.mzML* file parsed to the `ms`. Note that the `get_analyses()` method always returns a list even for only one MassSpecAnalysis object. Therefore, we use the `[[` function as `a1[[1]]` to access the MassSpecAnalysis object itself. The analysis object contains `r length(ms$get_analyses(1)[[1]])` fields (listed below) with information and data parsed directly from the *.mzML* file. Variations in the content and structure (i.e., different vendors or data acquired with different conditions or modes) of the *.mzML* or *.mzXML* files added will affect the content of each entry in the MassSpecAnalysis object but the structure remains the same (see `?MassSpecAnalysis`). The function `parse.MassSpecAnalysis()` from the streamFind R package is used to create and validate the list of MassSpecAnalysis objects from a character vector with *.mzML* or *.mzXML* full file paths (see `?parse.MassSpecAnalysis` for more information). The structure of the MassSpecAnalysis S3 class object is further described in section [analyses](#analyses). By typing `ms$get`, other available get methods are listed. The documentation `?MassSpecData` also contains detailed information and usage examples for available get methods.

```{r get-analyses}
a1 = ms$get_analyses(analyses = 1)

class(a1[[1]])

names(a1[[1]])
```

## Add methods

Add methods are used to add data to an existing MassSpecData object. For instance, below we add a new name and a description to the `ms` object with the method `add_headers()`. If entry names are already present in the MassSpecData object (e.g., *name*), the content of these are overwritten as shown below.

```{r add-headers}
ms$add_headers(name = "Ex1", description = "An example MassSpecData.")
```

```{r check-add-headers}
ms$get_headers()
```

Similarly, new MassSpecAnalysis objects can be added with `add_analyses()` as shown below. Note that the function `parse.MassSpecAnalysis()` was used to parse data from files 7, 8 and 9, creating a named list of analysis objects. Again the name of each MassSpecAnalysis in the list is the file name without extension. Then, the list is added to the `ms` object with the method `add_analyses()`. By typing `ms$add`, other available add methods are listed. The documentation `?MassSpecData` also contains detailed information and usage examples for available add methods.

```{r make-analysis-list}
a_list = parse.MassSpecAnalysis(files[7:9])

vapply(a_list, class, "")
```

```{r add-analyses}
ms$add_analyses(a_list)
```

```{r check-add-analyses}
ms
```

## Remove methods

Complementary to add methods, remove methods are used to remove data from an existing MassSpecData object. For instance, in the code chunk below the *name* and *description* are removed from the headers of the `ms` object. However, *name*, *path* and *date* cannot be removed. Even when one of these are specified, they are not removed. Yet, they can be changed with `add_headers()` method.

```{r remove-headers}
ms$remove_headers(c("name", "description"))
```

```{r check-remove-headers}
ms$get_headers()
```

Also, analyses can be removed with `remove_analyses()` method as shown below. When removing analyses, correspondence feature groups that were unique to those analyses are also removed from the MassSpecData object. By typing `ms$remove`, other available remove methods are listed. The documentation `?MassSpecData` also contains detailed information and usage examples for available remove methods.

```{r remove-analyses}
ms$remove_analyses(4:6)
```

```{r check-remove-analyses}
ms
```

## Subset methods

While remove methods changes the MassSpecData object by reference, the subset methods create a clone subset of the MassSpecData object. For instance, the method `subset_analyses()` is demonstrated below to create a clone of the `ms` object but with only the first 2 analyses. Note that the output behaves as a new MassSpecData object was created. In fact, that is what happens in the background. Also, note that when sub-setting all the other content (i.e., the other internal fields) are cloned to the new MassSpecData class object. For instance, the headers in the `subset_ms` object is the same as in `ms` object. All changes to the `subset_ms` object after its creation will not affect the `ms` object as it was cloned. For more information about copy and cloning R6 class objects you are recommended the [R6](https://r6.r-lib.org/index.html) official documentation. By typing `ms$subset`, other available subset methods are listed. The documentation `?MassSpecData` also contains detailed information and usage examples for available subset methods.

```{r subset-analyses}
subset_ms <- ms$subset_analyses(analyses = 1:2)

subset_ms
```

## Has methods

There are methods to simply check if data is present in the MassSpecData. These are the has methods as shown below. By typing `ms$has`, other available has methods are listed. The documentation `?MassSpecData` also contains detailed information and usage examples for available has methods.

```{r has-methods}
# check if settings are present
ms$has_settings()

# check if analyses are present
ms$has_analyses()

# check if features are present in analyses
ms$has_features()

# check if raw spectra are loaded to analyses
ms$has_loaded_spectra()
```

## Plot methods

Within the MassSpecData class object, standardized methods for plotting data are also available. All plot methods use data that can be obtained with get methods, meaning that the user is able to re-plot the data with a different approach/style. For instance, the `get_tic()` method can be used to obtain the total ion chromatogram (TIC) as a `data.table` with columns *analysis*, *rt* and *intensity*, as shown below for the first analysis. The same TIC data can be directly plotted using the `plot_tic()` method, as shown below.

```{r get-tic-first-analysis}
head(ms$get_tic(analyses = 1))
```

```{r plot-tic} 
ms$plot_tic(analyses = 1)
```

<br>

Note that plotting data which is not available (e.g., features in the current `ms` object as feature finding was not yet applied) returns `NULL` (demonstrated below).

```{r plot-not-present-data}
ms$plot_features()
```
 
<br>

Most plot methods have the *interactive* argument which is set to `TRUE` by default for using the [plotly](https://plotly.com/r/) package to plot the data. A static version of the plot using the base `plot()` function can be obtained by setting interactive to `FALSE`, as shown below for the base peak chromatogram (BPC) of all analyses in the `ms` object. By typing `ms$plot`, other available plot methods are listed. The documentation `?MassSpecData` also contains detailed information and usage examples for available plot methods.
 
```{r plot-bpc-static}
ms$plot_bpc(interactive = FALSE)
```

## Save methods

The MassSpecData object is stored by default in the environment of an R session and will be save within the *.RData* when `save.image()` function is used (by default save current environment is asked when an R session ends or is terminated). However, save methods are also available to save data within the internal fields in other formats. Currently only *.rds* and *.json* are possible. Below, the `save_headers()` method is used to save the Headers S3 class object as *.json*.

```{r save-headers-json}
ms$save_headers(format = "json", path = getwd())
```

```{r show-headers-json}
# the prettify function is applied for simplifying the json string output
jsonlite::prettify(readLines("headers.json"))
```

Similarly, `save_analyses()` method can be applied to export all or specific MassSpecAnalysis objects to *.rds* or *.json*. Below, the first MassSpecAnalysis object is exported as *.json* and named *a1*. Then in section [import methods](#import-methods), the exported analysis (*a1.json*) is imported to the `ms` object.

```{r}
ms$save_analyses(analyses = 1, format = "json", name = "a1")
```

Also, the entire `ms` object can be saved using the `save()` method as shown below. Other save methods are listed by typing `ms$save`. Again, the documentation `?MassSpecData` contains detailed information and usage examples for available save methods.

```{r save-entire-MassSpecData}
ms$save(format = "json", name = "ms", path = getwd())
```

## Import methods

Complementary to save methods, the *.json* or *.rds* files can be imported to the MassSpecData using the import methods. For instance, below the previously saved *headers.json* is imported back to the `ms` object. As in `add_headers()`, if entry names are already present, their content is overwritten.

```{r import-headers}
ms$import_headers("headers.json")
```

Also, the saved *a1.json* MassSpecAnalysis object can be imported with `import_analyses()` method. However, because the analysis name is already present in the `ms` object, an warning is printed and the operation not done (as shown below). The other internal fields (i.e., *settings*, *groups* and *alignment*) can be similarly imported. Validation and conformity tests are applied to ensure that the data has the required structure.

```{r import-analyses}
ms$import_analyses("a1.json")
```

A saved MassSpecData object can be imported from *.json* or *.rds* using the `import_MassSpecData()` function from the streamFind package. Below, the previously saved *ms.json* is imported and compared to the `ms`.

```{r import-MassSpecData}
ms_imported = import_MassSpecData("ms.json")
```

```{r check-import-MassSpecData}
all.equal(ms, ms_imported)
```

```{r remove-files-json-from-wd, include=FALSE}
file.remove(paste0(getwd(), "/headers.json"))
file.remove(paste0(getwd(), "/a1.json"))
file.remove(paste0(getwd(), "/ms.json"))
```

# Analyses

Within the MassSpecData object, the internal field analyses is a list of MassSpecAnalysis S3 class objects representing MS files on disk. As shown above in [MassSpecData](#msdata) section, the MassSpecData can be initiated with the `files` argument using a character vector of full file path/s to *.mzML* or *.mzXML* files. Alternatively, the function `parse.MassSpecAnalysis()` can be used to generate the list of analysis objects and then the argument `analyses` of the `new()` method or the `add_analyses()` method can be used to add the MassSpecAnalysis objects to the MassSpecData object. The package [mzR](https://bioconductor.org/packages/release/bioc/html/mzR.html) from [Bioconductor](https://bioconductor.org/) is used to parse the data. When the [mzR](https://bioconductor.org/packages/release/bioc/html/mzR.html) package is not available (i.e., not installed), the [xml2](https://cran.r-project.org/web/packages/xml2/index.html) package from CRAN is used instead but is much slower. Specially for large MS files (e.g., high resolution MS files with ion mobility), the [mzR](https://bioconductor.org/packages/release/bioc/html/mzR.html) package is recommended. The data parsed is the same independently of the package used. The structure of an example MassSpecAnalysis object is shown below and consists of 23 entries (see `?MassSpecAnalysis` for more information).

- **name** is the file name without extension;
- **replicate** is the analysis replicate group name; 
- **blank** is the associated blank replicate group name;
- **file** is the full file path;
- **type** is either "MS" for only MS1 spectral data, "MS/MS" for tandem spectral data (i.e., MS1 and MS2) or "SRM" for selected reaction monitoring data (i.e., no spectra only chromatograms);
- **instrument** is a list with metadata from the instrument used to acquire the data (content is highly vendor dependent);
- **time_stamp** is the start time and date of the data acquisition;
- **spectra_number** is the number of spectra in the file;
- **spectra_mode** is one of *centroid*, *profile* or `NA` for centroided data, data in profile mode or mode not defined or absence spectra, respectively.
- **spectra_levels** is the number of levels in the spectra (i.e., 1 or 1 and 2);
- **mz_low** is the lowest \emph{m/z} value detected in the spectra, in Da;
- **mz_high** is the highest \emph{m/z} value detected in the spectra, in Da;
- **rt_start** is the run start time, in seconds;
- **rt_end** is the run end time, in seconds;
- **polarity** is the polarity mode: *positive*, *negative* or *both* (the latter refers to polarity switching acquisition);
- **chromatograms_number** is the number of chromatograms (only applicable for *.mzML* files);
- **ion_mobility** `TRUE` or `FALSE` for presence or absence of drift separation from ion mobility;
- **tic** is a `data.table` with the total ion chromatogram;
- **bpc** is a `data.table` with the base peak chromatogram;
- **spectra** is a `data.table` with the raw spectra (only present if loaded with `load_spectra()` method);
- **chromatograms** is a `data.table` with the raw chromatograms (only present if loaded with `load_chromatograms()` method);
- **features** is a `data.table` with the features obtained from data processing (e.g., `find_features()` method);
- **metadata** is a `list` with flexible storage for experimental metadata (e.g., concentration, location, etc.);

```{r}
str(a1[[1]])
```

## Get basic information

The data from MassSpecAnalysis objects can be obtained with get methods as shown above. Below, methods to get information from analyses are demonstrated. In all methods except the `get_number_analyses()`, the analyses argument can be used to query information from specific analyses, using the analysis name or the index as shown below.

```{r}
# getter for number of analyses
ms$get_number_analyses()

# getter for file names (i.e., analysis names)
ms$get_analysis_names(analyses = 1:2)

# getter for file full paths of analyses
ms$get_files(3)

# getter for replicate group names
ms$get_replicate_names()

# getter for associated blank replicate group names
ms$get_blank_names()

# getter for polarities
ms$get_polarities(analyses = "00_hrms_s_is_pos_cent-r003")

# getter for lower mz value
ms$get_mz_low(c("00_hrms_s_is_pos_cent-r001", "00_hrms_s_is_pos_cent-r003"))

# getter for higher mz value
ms$get_mz_high()

# getter for start retention time
ms$get_rt_start()

# getter for retention time end
ms$get_rt_end()

# getter for MS levels. Note that it returns a list not a vector!
ms$get_spectra_levels()

# getter for spectra mode
ms$get_spectra_mode()

# getter for TIC
head(ms$get_tic(analyses = 2))

# getter for BPC
head(ms$get_bpc())
```

## Making spectra targets

Besides analysis information, low level data (i.e., spectra and chromatograms) can also be obtained with specific get methods. For spectra, the definition of targets to selectively parse small pieces of the raw data is essential. In streamFind, targets can be comprehensively assembled with the function `make_ms_targets()`, as demonstrated below for Carbamazepin-d10 and Diuron-d6 (both internal standards spiked to the analyses in the `ms` object). The function `make_ms_targets()` has five arguments (*mz*, *rt*, *ppm*, *sec* and *id*) that are used to assemble the targets. Below, different ways are demonstrated to build MS targets.

```{r carb-diu-db}
# Carbamazepin-d10 is ionized only in positive mode
carbamazepin_d10 <- db[name %in% "Carbamazepin-d10", .(name, mass, rt)]
carbamazepin_d10

# Expected m/z and time of Carbamazepin-d10
carb_mz_pos <- carbamazepin_d10$mass + 1.0073 # for positive ionization ([M+H]+)
carb_mz_pos
carb_rt <- carbamazepin_d10$rt
carb_rt

# Diuron-d6 is ionized in both positive and negative modes
diuron_d6 <- db[name %in% "Diuron-d6", .(name, mass, rt)]
diuron_d6

# Expected m/z and time of Diuron-d6
diu_mz_pos <- diuron_d6$mass + 1.0073 # for positive ionization ([M+H]+)
diu_mz_pos
diu_rt <- diuron_d6$rt
diu_rt

# Time and mass deviations to make the targets
sec_dev <- 30 # in seconds
ppm_dev <- 20 # in ppm
```

**Case 1:** Individual *m/z* and time targets with deviations.
```{r case-one}
# m/z targets, in Da
mz1 <- c(carb_mz_pos, diu_mz_pos)

# Time targets, in seconds
rt1 <- c(carb_rt, diu_rt)

# Optional identifiers for the targets
id1 <- c("target1", "target2")

targets1 <- make_ms_targets(mz = mz1, rt = rt1, ppm = ppm_dev, sec = sec_dev, id = id1)

targets1
```

**Case 2:** *m/z* and time minimum and maximum ranges as `data.frame` given in `mz` and `rt`, respectively.
```{r case-two}
# Calculating mass deviation in Da from 200 ppm
ppm_carb <- ppm_dev / 1E6 * carb_mz_pos
ppm_diu <- ppm_dev / 1E6 * diu_mz_pos

# Min and Max m/z ranges, in Da
mz2 <- data.frame(
  "mzmin" = c(carb_mz_pos - ppm_carb, diu_mz_pos - ppm_diu),
  "mzmax" = c(carb_mz_pos + ppm_carb, diu_mz_pos + ppm_diu)
)
# Min and Max time ranges, in seconds
rt2 <- data.frame(
  "rtmin" = c(carb_rt - sec_dev, diu_rt - sec_dev),
  "rtmax" = c(carb_rt + sec_dev, diu_rt + sec_dev)
)

targets2 <- make_ms_targets(mz = mz2, rt = rt2)

targets2
```

**Case 3:** *m/z* and time targets given as a `data.frame` in `mz` and mass and time deviations given in `ppm` and `sec`, respectively.
```{r case-three}
# data.frame with m/z and time targets
mz3 <- data.frame(
  "id" = c("target1", "target2"),
  "mz" = c(carb_mz_pos, diu_mz_pos),
  "rt" = c(carb_rt, diu_rt)
)

targets3 <- make_ms_targets(mz = mz3, ppm = ppm_dev, sec = sec_dev)

targets3
```

**Case 4:** *m/z* and time minimum and maximum ranges given directly as a `data.frame` in `mz`. 
```{r case-four}
# data.frame with m/z and time minimum and maximum ranges
mz4 <- data.frame(
  "id" = c("target1", "target2"),
  "mzmin" = c(carb_mz_pos - ppm_carb, diu_mz_pos - ppm_diu),
  "mzmax" = c(carb_mz_pos + ppm_carb, diu_mz_pos + ppm_diu),
  "rtmin" = c(carb_rt - sec_dev, diu_rt - sec_dev),
  "rtmax" = c(carb_rt + sec_dev, diu_rt + sec_dev)
)

targets4 <- make_ms_targets(mz = mz4)

targets4
```

Although different ways were used to build the `data.frame` with the targets, the result should be the same as tested below. Note that when exact mass (or *m/z*) and time targets are not given (i.e., only given minimum and maximum ranges), these are calculated as an average of the minimum and maximum values (see cases 2 and 4 above).

```{r test-targets}
#test all equal target 1
t1 <- rbind(targets1[1, ], targets2[1,], targets3[1, ], targets4[1, ])
all(round(apply(t1[, 2:7], 2, sd), digits = 4) == 0) 

#test all equal target 2
t2 <- rbind(targets1[2, ], targets2[2,], targets3[2, ], targets4[2, ])
all(round(apply(t2[, 2:7], 2, sd), digits = 4) == 0)
```

## Get and plot spectra

Besides the `get_tic()` and `get_bpc()` methods (shown above). There are four methods to get low level spectra from analyses: `get_spectra()`, `get_eic()`, `get_ms1()` and `get_ms2()`. All methods use the same arguments as the function `make_ms_targets()` to build MS targets and the *analyses* argument to specify which MassSpecAnalysis objects to query the data. All methods return a `data.table`. The documentation in `?MassSpecData` has detailed information about the use of each method. For each get method, a plot method is available with similar interface. Below each get and plot method is demonstrated for the defined targets.

### Mass traces

Spectra can be obtained with `get_spectra()` method and plotted with `plot_spectra()`. When the `levels` argument includes 2, extra columns are given with the applied collision energy (ce), the precursor scan number (preScan) and the isolated *m/z* value (preMZ). Arguments `minIntensityMS1` and `minIntensityMS2` can be used to define a minimum intensity of parsed mass traces. The `allTraces` argument can be set to `FALSE` for only returning MS2 data correspondent of defined targets. For this, the `isolationWindow` argument is used to calculate the isolation window of each target and retrieve the MS2 based on the preMZ and rt columns (this is demonstrated below in the second spectra plot).

```{r raw-spectra-01}
# Getter for level 1 raw spectra of targets from analysis 1
head(ms$get_spectra(analyses = 1, mz = targets1, levels = 1))
```

```{r raw-spectra-02}
# Getter for level 2 raw spectra of targets from analysis 1
head(ms$get_spectra(analyses = 1, mz = targets1, levels = 2))
```

```{r plot-raw-spectra-01}
# Plots raw spectra (level 1) of all analyses with intensity above 1000
ms$plot_spectra(mz = targets1, levels = 1, minIntensityMS1 = 1000)
```

```{r plot-raw-spectra-02}
# Plots raw spectra (level 1 and 2) of analysis 2 and target 1 while coloring by levels
# Note that allTraces was set to FALSE to retrieve MS2 of MS1 targets considering an isolation window of 1.3 Da
ms$plot_spectra(
  analyses = 2, mz = targets1[1, ], levels = c(1,2), 
  allTraces = FALSE, isolationWindow = 1.3, colorBy = "levels",
  minIntensityMS1 = 1000, minIntensityMS2 = 10
)
```

Another plotting option for raw spectra is the `plot_xic()` method as shown below. This method returns a two row plot with traces intensity vs retention time on top and *m/z* vs retention time below. A `targetsMark` can be defined to illustrate the area of expected *m/z* and retention time targets. Below, the targets1 rt and mz columns with narrower ppm and sec deviations (i.e., 5 ppm and 10 seconds, respectively) is used to show the area where Carbamazepin-d10 is expected for potential identification.

```{r plot-xic}
ms$plot_xic(analyses = 1:2, mz = targets1[2,],
  targetsMark = targets1[2, c("rt", "mz")], ppmMark = 5, secMark = 10)
```

### EIC

The extracted ion chromatogram (EIC) can be obtained with `get_eic()` and plotted with `plot_eic()` method. The interface is very similar as the previous methods, with analyses and make targets arguments used to specify each analyses to parse the data and which traces to retrieve.

```{r get-eic-01}
ms$get_eic(analyses = 1, mz = mz1, rt = rt1, ppm = 5, sec = 10)
```

```{r plot-eic-01}
ms$plot_eic(mz = targets1, interactive = FALSE)
```

```{r plot-eic-02}
ms$plot_eic(mz = targets1, colorBy = "analyses")
```

### MS1 and MS2 spectra

While the EIC method collects and sums the traces in each retention time value (i.e., in each scan), the `get_ms1()` and `get_ms2()` methods average the mass traces in a given retention time interval, returning an averaged spectrum representing several scans. The averaging is based on clustering the mass traces according to a given `mzClust` argument as demonstrated below for both MS1 and MS2 data.

```{r get-ms1}
# MS1 averaged spectrum of targets from 247 to 257 (Carbamazepin-d10) and 239 to 245 (Diuron-d6) m/z and +/- 1 second the retention time of each target
ms$get_ms1(analyses = 3, mzClust = 0.005,
  mz = data.frame("mzmin" = c(247, 239), "mzmax" = c(257, 245)),
  rt = data.frame("rtmin" = targets1$rt - 1, "rtmax" = targets1$rt + 1)
) 
```

```{r plot-ms1}
# In the plot, the Carbamazepin-d10 and Diuron-d6 isotopes can be distinguished
ms$plot_ms1(analyses = 3,
  mz = data.frame("mzmin" = c(247, 239), "mzmax" = c(257, 245)),
  rt = data.frame("rtmin" = targets1$rt - 1, "rtmax" = targets1$rt + 1),
  mzClust = 0.005, interactive = FALSE
)
```

```{r get-ms2}
# MS2 data of Diuron-d6 for analysis 1
ms$get_ms2(analyses = 1, mz = targets1[2, ])
```

```{r plot-ms2-01}
# MS2 data plot of Diuron-d6 in all analyses
ms$plot_ms2(mz = targets1[2 ,], 
  mzClust = 0.005, minIntensity = 50,
  colorBy = "analyses", verbose = FALSE)
```

```{r plot-ms2-02}
# MS2 data plot of both targets in analyses 3
# Note that "minIntensity" argument was increased to 500 counts, resulting in a cleaner averaged spectrum
ms$plot_ms2(analyses = 3, mz = targets1, 
  mzClust = 0.005, minIntensity = 500,
  colorBy = "targets", verbose = FALSE)
```

# Centroiding

Possible using the function `convert_ms_files()` which utilizes the [MSConvert](https://proteowizard.sourceforge.io/download.html) command line interface. See `help(convert_ms_files)` for more information. Alternative centroiding to be implemented.

# Processing settings

Data processing steps often require settings with parameters to support the application of a given function to the data. In the MassSpecData object, methods that require settings have the `settings` argument (e.g., the method `find_features()`). In the streamFind package, the `settings` argument takes a ProcessingSettings S3 class and list object (see `?ProcessingSettings`) with three mandatory elements: *call*, *algorithm* and *parameters*. The *call* defines the name of the method (or processing step to be applied), such as "find_features" or "group_features". The *algorithm* defines the algorithm to be used for the processing step (e.g., "xcms" or "openms"). Finally, the *parameters* are a list of algorithm dependent entries that define the settings to be applied during the data processing. An example for "find_features" settings using the algorithm "xcms" is given below. Most of the data processing methods in streamFind use the package [patRoon](https://github.com/rickhelmus/patRoon). Therefore, the interface parameters is similar. The algorithm and parameters (named "param" in [patRoon](https://github.com/rickhelmus/patRoon)) can be taken from the respective documentation of the equivalent function. For instance, the `find_features()` method in streamFind uses the [findFeatures()](https://rickhelmus.github.io/patRoon/reference/findFeatures.html) function in [patRoon](https://github.com/rickhelmus/patRoon). The documentation of each data processing method in `?MassSpecData` explains and exemplifies the usage and where the required settings can be acquired in [patRoon](https://github.com/rickhelmus/patRoon).

```{r ff-settings-xcms}
settingsFindFeatures <- ProcessingSettings(
  "call" = "find_features",
  "algorithm" = "xcms3",
  "parameters" = list(
    xcms::CentWaveParam(
      ppm = 12,
      peakwidth = c(5, 40),
      snthresh = 10,
      prefilter = c(5, 1500),
      mzCenterFun = "mean",
      integrate = 2,
      mzdiff = -0.0001,
      fitgauss = TRUE,
      noise = 500,
      verboseColumns = TRUE,
      firstBaselineCheck = FALSE,
      extendLengthMSW = TRUE
    )
  )
)

settingsFindFeatures
```

The ProcessingSettings object can be added to the MassSpecData object with the `add_settings()` method as shown below. Similarly, it can be obtained with the `get_settings()` method using the call name as also shown below.

```{r add-ff-xcms}
ms$add_settings(settings = settingsFindFeatures)
```

```{r get-ff-xcms}
# Note that it returns a named list, therefore we access it with the [[ method
ms$get_settings(call = "find_features")[["find_features"]]
```

# Features

Extraction of features from raw MS data is a frequent step applied during data processing for easing prioritization and identification of chemicals in a given analysis (i.e., sample). A feature in essence describes a chromatographic peak composed fundamentally of three values: mass-to-charge ratio (*m/z*), retention time (rt) and intensity. The method `find_features()` from a MassSpecData object can be used to extract features from files represented by the MassSpecAnalysis objects. Several algorithms (i.e., software) are available for finding features through the [patRoon](https://github.com/rickhelmus/patRoon) package as above mentioned. Some algorithms require spectral data in profile mode but most use centroided data (see [centroiding](#centroiding) section for more information about centroid vs profile mode). Below, we use the added settings to find features from the analyses in the object `ms`. Note that the argument `settings` was not used (`NULL` is the default value) as the settings were already added to the object. Adding settings via the argument `settings` during call for method `find_features()` would replace existing settings in the MassSpecData object with call name "find_features". If settings with call name "find_features" are not available or given, features are not extracted.

```{r ff-01, warning=FALSE, results='hide'}
ms$find_features(settings = NULL)
```

```{r print-ms-after-ff}
# Check for presence of features in analyses
ms$has_features()

# Show method giving the number of features
ms
```

## Get features

As above described, there are get methods to parse data from a MassSpecData class object. For features, the method `get_features()` can be used as shown below. When no arguments are given, the features `data.table` in each MassSpecAnalysis object is collated without filtering and a column analysis is given to make reference for the analysis that the corresponding features belong to.

```{r get-all-features}
head(ms$get_features())
```

The same arguments from `make_ms_targets()` are available. Below the corresponding feature of Carbamazepin-d10 in each analysis object is extracted using the `mz` and `rt` arguments.

```{r get-features-targets-01}
ms$get_features(mz = carb_mz_pos, rt = carb_rt, ppm = 5, sec = 10)
```

The features `data.table` contain the following mandatory columns:

 - **analysis**: (character) The file name without extension;
 - **feature**: (character) The unique identifier of the feature in the analysis;
 - **index**: (numeric) The index of the feature in the analysis;
 - **mz**: (numeric) The calculated *m/z* from feature mass traces (i.e., centroids), in Da;
 - **rt**: (numeric) The calculated retention time from feature mass traces, in seconds;
 - **mzmin**: (numeric) The minimum *m/z* value of the feature mass traces, in Da;
 - **mzmax**: (numeric) The maximum *m/z* value of the feature mass traces, in Da;
 - **rtmin**: (numeric) The minimum retention time value of the feature mass traces, in seconds;
 - **rtmax**: (numeric) The maximum retention time value of the feature mass traces, in seconds;
 - **intensity**: (numeric) The calculated height of the features, in counts; 
 - **area**: (numeric) The calculated area of the integrated feature;
 
Other columns added from specific algorithms or added by streamFind after feature extraction are:

 - **adduct**: (character) The adduct label of the feature (e.g., [M+H]+, [M-H]-, [M+Na]+), see  [isotopes and adducts](#isotopes-and-adducts) section for more information;
 - **mass**: (numeric) The calculated neutral mass of the feature based on the polarity of the analysis;
 - **is_filled**: (logical) `TRUE` means that the feature was built with recursive integration (i.e., integrated after correspondence analysis, see [groups](#groups) section for more information);
 - **filtered**: (logical) `TRUE` means that the feature was filtered out from the set but still remained in the data set (see [filters](#filters) section for more information);
 - **filter**: (character) The filter tag or `NA_character_` if the feature is not filtered (i.e., filtered is `FALSE`);
 - **sn**: (numeric) The calculated signal-to-noise ratio of the feature;
 - **ms1** data.table with averaged spectrum from MS1 spectra data within defined mass and time ranges;
 - **ms2** data.table with averaged spectrum from MS2 spectra data that correspond to the isolation window of the feature mass and time ranges;

## Plot features

There are two methods to plot features: `plot_features()` and `map_features()`. Both methods are demonstrated below for the features correspondent of the target chemicals. While the `plot_features()` method plots the chromatogram to inspect intensity, shape and other fitting aspects the `map_features()` method plots the time and mass space (shaded area) of the features as well as the calculate *m/z* and retention time values (dots). For instance, when applying correspondence analysis (more information in [groups](#groups) section), these plots can be used to evaluate the most appropriate mass and time deviations to consider in the processing settings.

```{r plot-features-targets-01}
ms$plot_features(analyses = 1, mz = targets1, colorBy = "targets", interactive = FALSE)
```

```{r plot-features-targets-02}
ms$plot_features(mz = targets1, colorBy = "analyses", interactive = TRUE)
```

```{r map-features-targets-01}
ms$map_features(mz = targets1, colorBy = "analyses", interactive = TRUE)
```

## Get features MS1 and MS2

As mentioned, each feature represents an MS1 level chromatographic peak. The averaged MS1 spectrum can be obtained with the method `get_features_ms1()`. Spectra within the feature mass and time space are collected and clustered according to a `mzClust` argument (in Da), as shown below.  The arguments `rtWindow` and `mzWindow` can be used to narrow or extend the space for collection of mass traces. In the example below, the time window for collection of mass traces will be plus/minus 2 seconds the calculated retention time of the feature found by the `mz` and `rt` arguments; In the example, it is the feature correspondent to Carbamazepin-d10. The mass window will be -1 Da and +6 Da the calculated *m/z*. When both `rtWindow` and `mzWindow` are `NULL`, the integrated feature space (as plotted by the `map_features()` method) will be used. A `minIntensity` argument is used to filter mass traces below an intensity threshold. In the example below, it was set to 1000 counts, to exclude low intensity mass traces. The `data.table` obtained can be plotted directly with the `plot_features_ms1()` method as shown below.

```{r get-features-ms1}
ms$get_features_ms1(analyses = 2, mz = carb_mz_pos, rt = carb_rt,
  ppm = 20, sec = 30, rtWindow = c(-2, 2), mzWindow = c(-1, 6),
  mzClust = 0.003, minIntensity = 1000
)
```

```{r plot-features-ms1}
# Plotting the MS1 spectrum of both Carbamazepin-d10 and Diuron-d6 in analyses 2
ms$plot_features_ms1(analyses = 2, verbose = FALSE,
  mz = targets1, rtWindow = c(-2, 2), mzWindow = c(-1, 6),
  mzClust = 0.003, minIntensity = 1000, colorBy = "targets"
)
```

MS2 data from features is obtained with the `get_features_ms2()` method, as shown below. For MS2, the arguments `mzClust` and `minIntensity` are applied the same way as for MS1. However, when extracting traces an isolation window (in Da) should be set using the argument `isolationWindow`. The isolation window should match with the settings used to isolate precursor ions during fragmentation from tandem MS. Below we set the `isolationWindow` to 1.3 Da, which extends the *mzmin* to *mzmax* range of the feature by $-\frac{1.3}{2}$ and $+\frac{1.3}{2}$, respectively. Plotting the `data.table` can also be directly performed with the `plot_features_ms2()` method as shown below.

```{r get-features-ms2}
ms$get_features_ms2(analyses = 3, mz = carb_mz_pos, rt = carb_rt,
  ppm = 20, sec = 30, isolationWindow = 1.3, mzClust = 0.003,
  minIntensity = 500, verbose = FALSE
)
```

```{r plot-features-ms2}
ms$plot_features_ms2(mz = carb_mz_pos, rt = carb_rt,
  ppm = 20, sec = 30, isolationWindow = 1.3, mzClust = 0.003,
  minIntensity = 500, colorBy = "analyses", verbose = FALSE
)
```

```{r plot-features-ms2-2}
ms$plot_features_ms2(analyses = 1, mz = targets1,
  isolationWindow = 1.3, mzClust = 0.003,
  minIntensity = 500, colorBy = "targets",
  interactive = FALSE, verbose = FALSE
)
```

## Load features MS1 and MS2

MS1 and MS2 spectra can support identification processing steps by giving additional information from isotopic and specific fragmentation patterns, respectively. The methods `load_features_ms1()` and `load_features_ms2()` are used for systematically load averaged MS1 and MS2 spectra for features in a MassSpecData class object. Both methods have a `settings` argument which takes a settings object similar to "find_features" settings but with the specific call name, which is the method name, as shown below. The parameters are the same as the arguments of the respective get methods (see above in [get features ms1 and ms2](#get-features-ms1-and-ms2)). The settings can be also added to the settings internal field as explained above in [processing settings](#processing-settings) section. This allows for internal data re-processing, inspection and retrospective evaluation.

```{r features-ms1-ms2-settings}
# Settings for loading features MS1 spectra
settingsLoadFeaturesMS1 <- ProcessingSettings(
  "call" = "load_features_ms1",
  "algorithm" = "streamFind",
  "parameters" = list(
    rtWindow = c(-2, 2),
    mzWindow = c(-1, 6),
    mzClust = 0.003,
    minIntensity = 500,
    filtered = FALSE,
    runParallel = FALSE,
    verbose = FALSE
  )
)

ms$add_settings(settings = settingsLoadFeaturesMS1)

# Settings for loading features MS2 spectra
settingsLoadFeaturesMS2 <- ProcessingSettings(
  "call" = "load_features_ms2",
  "algorithm" = "streamFind",
  "parameters" = list(
    isolationWindow = 1.3,
    mzClust = 0.003,
    minIntensity = 250,
    filtered = FALSE,
    runParallel = FALSE,
    verbose = FALSE
  )
)

ms$add_settings(settings = settingsLoadFeaturesMS2)

# Returns the names of the settings list, which is also the call or method name
names(ms$get_settings())
```

```{r subset-ms-target-features}
# The ms object is first reduced in size to ease computation for this example
targetFeatures <- ms$get_features(mz = targets1)
targetFeatures <- targetFeatures[, c("analysis", "feature"), with = FALSE]
targetFeatures

# Only the features from targets are kept in the MassSpecData object
msTargets <- ms$subset_features(features = targetFeatures)

# Only 2 features in each analysis object
msTargets
```

As the settings were already added to `ms`, the settings are also in `msTargets`. In general, the sub-setting methods transfer everything to the new MassSpecData object except what is to be excluded (see [subset-methods](#subset-methods) section for more information). Below, the MS1 spectra for the remaining features (i.e., feature corresponding to Carbamazepin-d10 and Diuron-d6 in each analysis) are loaded to the `msTargets`.

```{r load-ms1-targets}
msTargets$load_features_ms1()

msTargets$has_loaded_features_ms1()
```

When loaded, the MS1 data is added as a new column in the features `data.table` of each analysis object. Therefore, there are two ways of getting the MS1 spectra as demonstrated below. The use of `get_features_ms1()` method is recommended over accessing directly from the features `data.table`. The method `get_features_ms1()` has the argument *loadedMS1* set to `TRUE` by default for when loaded MS1 spectra are present, data is queried from the loaded spectra rather then extracting from raw data. Note that when *loadedMS1* is `TRUE`, averaging settings are ignored as the spectra were already averaged during loading of MS1 data. If *loadedMS1* is set to `FALSE`, data is extracted from raw data even if loaded spectra are present in the features table.

```{r get-loaded-ms1-1}
msTargets$get_features_ms1(analyses = 1, mz = targets1, loadedMS1 = TRUE)
```

```{r plot-loaded-ms1-1}
# Plotting all loaded MS1 spectra by feature id
msTargets$plot_features_ms1(loadedMS1 = TRUE)
```

As an alternative, MS1 spectra can be obtained directly from the features `data.table` as shown below but it is not recommended.

```{r get-loaded-ms1-2}
# Get MS1 spectra from features data.table
ms1FromFeaturesDataTable <- msTargets$get_features()
head(ms1FromFeaturesDataTable)

# Column ms1 is a list of data.table objects with the spectrum of each feature or NULL when a given feature does not have mass traces
class(ms1FromFeaturesDataTable$ms1)

# Extract the first spectrum with the "[[" method
ms1FromFeaturesDataTable$ms1[[1]]
```

Similarly to MS1, MS2 data can be loaded as shown below. Note the settings were already added to the former `ms` object. Still, one can add the settings again in the method call. The previously stored settings will then be overwritten. In this case, there is no change as the settings are the same.

```{r load-ms1-ms2-targets}
msTargets$load_features_ms2(settings = settingsLoadFeaturesMS2)

msTargets$has_loaded_features_ms2()
```

The loaded MS2 spectra can be obtained with the method `get_features_ms2()` with the argument *loadedMS2* set to `TRUE` (the default value). Alternatively, but not recommended, the MS2 spectra can be obtained directly from the features `data.table` as shown above for MS1 spectra.

```{r get-loaded-ms2-1}
# The first 6 lines of the MS2 spectra
head(msTargets$get_features_ms2(analyses = 1, mz = targets1, loadedMS2 = TRUE))
```

```{r plot-loaded-ms2-1}
# Plotting all loaded MS2 spectra in analysis 2 by feature id
msTargets$plot_features_ms2(analyses = 2, loadedMS2 = TRUE)
```

When MS1 or MS2 data is not available for a given feature (i.e., within the feature *m/z* and retention time window there is no mass traces or the MS1 traces were not fragmented, respectively), a `NULL` value is given. So, in the *ms1* and *ms2* columns of the features `data.table` a `NULL` entry is present if the spectrum is absent. When returning bulk MS1 and MS2 spectra with `get_features_ms1()` and `get_features_ms2()`, respectively, the features with `NULL` (no spectra) are not listed in the returned `data.table`.

## Remove features MS1 and MS2

Loaded MS1 and MS2 feature spectra can be removed using the `remove_features_ms1()` and `remove_features_ms2()`. Note that all the loaded spectra are removed as no argument can be given to remove only certain spectra. This means that if features MS1 or MS2 spectra are loaded, they are loaded for all features. Removing features from the MassSpecData object will also remove MS1 and MS2 spectra as they are in the features `data.table`.

```{r remove-features-ms1-ms2}
msTargets$remove_features_ms1()
msTargets$has_loaded_features_ms1()

msTargets$remove_features_ms2()
msTargets$has_loaded_features_ms2()
```

# Isotopes and adducts

Not yet implemented.

# Groups

After extraction of features, correspondence analysis (i.e., grouping of features across analyses) is often applied as a following processing step. The result from correspondence analysis is feature groups, describing the correspondent features in each analysis. The method `group_features()` is used for correspondence analysis of features in a MassSpecData object. Similarly to `find_features()`, the `group_features()` method uses settings. Also here the [patRoon](https://github.com/rickhelmus/patRoon) package is used in the background. More precisely, the function [groupFeatures()](https://rickhelmus.github.io/patRoon/reference/groupFeatures.html) from [patRoon](https://github.com/rickhelmus/patRoon) is used. Therefore, the settings algorithm and parameters can be obtained by the documentation of [groupFeatures()](https://rickhelmus.github.io/patRoon/reference/groupFeatures.html). Below the correspondence analysis is demonstrated using the algorithm "xcms".

```{r grouping-settings}
settingsGroupFeatures <- ProcessingSettings(
  "call" = "group_features",
  "algorithm" = "xcms3",
  "parameters" = list(
    rtalign = FALSE,
    groupParam = xcms::PeakDensityParam(
      # sampleGroups is set to "holder" but is updated with replicate names by the method
      sampleGroups = "holder",
      bw = 5,
      minFraction = 0.5,
      minSamples = 1,
      binSize = 0.008,
      maxFeatures = 100
    )
  )
)
```

```{r group-features, results='hide'}
ms$group_features(settings = settingsGroupFeatures)
```

## Get groups

Feature groups are stored in the groups internal field as a `data.table`, which can be obtained with the method `get_groups()`, as shown below. The groups `data.table` has the mandatory columns:

 - **group**: (character) The identifier of the feature group;
 - **rt**: (numeric) The averaged retention time of the features in the group, in seconds;
 - **mz**: (numeric) The averaged *m/z* of the features in the group, in Da (not present for MassSpecData with multiple polarities);
 - **mass**: (numeric) The averaged neutral mass of the features in the group, in Da;
 - **adduct**: (character) The adduct ion assigned to the feature group;
 - **drt**: (numeric) The time deviation range of the feature group, in seconds;
 - **dppm**: (numeric) The mass deviation range of the feature group, in ppm;
 - **index**: (integer) The unique index of the feature group;
 - **hasFilled**: (logical) When `TRUE`, the feature group has features obtained by recursive integration applied after  correspondence analysis for filling analysis objects with missing features;
 - **filtered**: (logical) `TRUE` means that the feature group was filtered out from the set but still remained in the data set (see [filters](#filters) section for more information);
 - **filter**: (character) The filter tag or `NA_character_` if the feature group is not filtered (i.e., filtered is `FALSE`);

For each MassSpecAnalysis object, a column with the analysis name is added to the groups `data.table` with the intensity of the feature. Other columns are added by streamFind from specific workflow methods but these are explained in the respective method demonstration and documentation.

```{r get-groups-field}
head(ms$get_groups())
```

```{r get-groups-targets}
# Groups correspondent of CArbamazepin-d10 and Diuron-d6 
ms$get_groups(mz = targets1)
```

## Plot groups

As for features, plotting methods for groups are also available. Below the methods `plot_groups()` and `plot_groups_overview()` are demonstrated. Further information about usage is available in the MassSpecData documentation (`?MassSpecData`).

```{r plot-groups}
ms$plot_groups(mz = targets1, colorBy = "analyses")
```

```{r plot-groups-overview, fig.height=8}
# Plots an overview of the features within the group for each analysis
ms$plot_groups_overview(mz = targets1)
```

## Get groups MS1 and MS2

MS1 and MS2 spectra spectra for groups can be obtained with the methods `get_groups_ms1()` and `get_groups_ms2()`, respectively. Note that average MS1 and MS2 for feature groups (i.e., across analyses) requires pre-averaging of spectra within each feature. Therefore, the arguments for averaging spectra for features are available in the methods, as shown below. These can be set differently for averaging spectra within features and within feature groups. Below the same values are used for both.

```{r get-groups-ms1}
ms$get_groups_ms1(mz = carb_mz_pos, rt = carb_rt,
  ppm = 20, sec = 30, rtWindow = c(-2, 2), mzWindow = c(-1, 6),
  mzClustFeatures = 0.003, minIntensityFeatures = 1000,
  mzClustGroups = 0.003, minIntensityGroups = 1000
)
```

```{r plot-groups-ms1}
ms$plot_groups_ms1(mz = targets1,
  ppm = 20, sec = 30, rtWindow = c(-2, 2), mzWindow = c(-1, 6),
  mzClustFeatures = 0.003, minIntensityFeatures = 1000,
  mzClustGroups = 0.003, minIntensityGroups = 1000,
)
```

```{r get-groups-ms2}
ms$get_groups_ms2(mz = carb_mz_pos, rt = carb_rt,
  ppm = 20, sec = 30, isolationWindow = 1.3,
  mzClustFeatures = 0.003, minIntensityFeatures = 500,
  mzClustGroups = 0.003, minIntensityGroups = 500
)
```

```{r plot-groups-ms2}
ms$plot_groups_ms2(mz = targets1,
  ppm = 20, sec = 30, isolationWindow = 1.3,
  mzClustFeatures = 0.003, minIntensityFeatures = 500,
  mzClustGroups = 0.003, minIntensityGroups = 500
)
```

## Load groups MS1 and MS2

Similarly to features, loading MS1 and MS2 spectra for feature groups is also possible via the methods `load_groups_ms1()` and `load_groups_ms2()`. Also here settings are used for loading the spectra and when spectra are not available for a given feature group, `NULL` is returned. Below, the loading process is demonstrated for a subset as earlier shown.

```{r grouping-ms1-ms2, results='hide'}
targetGroups <- ms$get_groups(mz = targets1)

# Only the groups from targets are kept in the MassSpecData object
msTargets <- ms$subset_groups(groups = targetGroups$group)

# Removing filtered features (i.e., not belonging to targeted groups)
msTargets$remove_features(filtered = TRUE)

# Only 6 features and 2 groups left 
msTargets
```

```{r groups-ms1-ms2-settings}
# Settings for loading groups MS1 spectra
settingsLoadGroupsMS1 <- ProcessingSettings(
  "call" = "load_groups_ms1",
  "algorithm" = "streamFind",
  "parameters" = list(
    mzClust = 0.003,
    minIntensity = 500,
    filtered = FALSE,
    runParallel = FALSE,
    verbose = FALSE
  )
)

msTargets$add_settings(settings = settingsLoadGroupsMS1)

# Settings for loading groups MS2 spectra
settingsLoadGroupsMS2 <- ProcessingSettings(
  "call" = "load_groups_ms2",
  "algorithm" = "streamFind",
  "parameters" = list(
    mzClust = 0.003,
    minIntensity = 250,
    filtered = FALSE,
    runParallel = FALSE,
    verbose = FALSE
  )
)

msTargets$add_settings(settings = settingsLoadGroupsMS2)

# Returns the names of the settings list, which is also the call or method name
names(msTargets$get_settings())
```

```{r load-groups-ms1}
msTargets$load_groups_ms1()

msTargets$has_loaded_groups_ms1()
```

```{r load-groups-ms2}
msTargets$load_groups_ms2()

msTargets$has_loaded_groups_ms2()
```

Note that features MS1 and MS2 spectra were removed in section [remove features ms1 and ms2](#remove-features-ms1-and-ms2), so when `load_groups_ms1()` and `load_groups_ms2()` are applied without MS1 and MS2 spectra for features, the previously loaded settings are used to reload the spectra from features before averaging spectra within feature groups. Once the MS1 and MS2 spectra are loaded, the get and plot methods use by default the loaded spectra. Below the plotting methods are demonstrated without adding averaging arguments.

```{r get-groups-ms1-01}
msTargets$plot_groups_ms1(mz = targets1)
```

```{r get-groups-ms2-01}
msTargets$plot_groups_ms2(mz = targets1)
```

## Remove groups MS1 and MS2

Also for feature groups, the methods `remove_groups_ms1()` and `remove_groups_ms2()` can be used to clear the MS1 and MS2 spectra from the groups `data.table` in the MassSpecData class object, as shown below.

```{r remove-groups-ms1-ms2}
msTargets$remove_groups_ms1()
msTargets$has_loaded_groups_ms1()

msTargets$remove_groups_ms2()
msTargets$has_loaded_groups_ms2()
```

# Recursive integration

Not yet implemented.

# Filters

Not yet implemented.

# Outlook 

The streamFind R package is experimental. This article showed the preliminary framework for mass spectrometry. This article will be updated with future developments for MS data processing. Please [contact us](mailto:cunha@iuta.de) for questions, suggestions, issues or collaboration.

```{r clean-up, include=FALSE}
patRoon::clearCache()
```

