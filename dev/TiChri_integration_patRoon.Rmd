---
title: "TiChri: Matrix correction integration in patRoon"
author:
  name: Ricardo Cunha
  email: cunha@iuta.de
  affiliation: "Institut f√ºr Umwelt & Energie, Technik & Analytik e. V. (IUTA) <br> Bliersheimer Str. 58 - 60, 47229 Duisburg"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  bookdown::html_document2:
    toc: yes
    toc_float: yes
    theme: paper
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
# Libraries
library(data.table)
library(knitr)
library(kableExtra)
library(magrittr)
library(ggplot2)
library(plotly)
library(StreamFind)
library(patRoon)
# Global options
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.width = 9, results = "asis", cache = TRUE)
options(width = 400)
```

<style>
.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {
  background-color: #1E8449;
}
</style>

```{r logo, echo=FALSE}
path_extdata <- system.file(package = "StreamFindData", dir = "extdata")
logo <- file.path(path_extdata, "logo_StreamFind.png")
htmltools::img(src = knitr::image_uri(logo), style = "margin-left:inherit;position:absolute;top:100px;left:740px;width:200px;")
```

<br>

***

```{r resources, include=FALSE}
files <- list.files("D:/NTS/Project_220614_AirLiquid_220509_SPE/msfiles", full.names = TRUE)
selected_files <- files[grepl("pos_Blank|pos_M220509014|pos_M220509017|pos_M220509018", files)]

all_db <- StreamFindData::get_ms_tof_spiked_chemicals_with_ms2()
db <- all_db[!grepl("IS", all_db$tag, fixed = TRUE), ]
cols <- c("name", "formula", "mass", "SMILES", "rt")
db <- db[, cols, with = FALSE]

dbis <- all_db[grepl("IS", all_db$tag), ]
cols <- c("name", "formula", "mass", "rt")
dbis <- dbis[, cols, with = FALSE]
```

# AnalysisInfo

```{r anaInfo}
anaInfo <- data.frame(
  "path" = dirname(selected_files),
  "analysis" = tools::file_path_sans_ext(basename(selected_files)),
  "group" = c(
    rep("blank", 2),
    rep("effluent_OZ", 2),
    rep("effluent_OSW", 2),
    rep("influent", 2)
  ),
  "blank" = rep("blank", 8)
)

kable(anaInfo, caption = "AnalysisInfo") %>%
  kable_styling(
    font_size = 12,
    bootstrap_options = c("striped", "hover", "condensed"),
    fixed_thead = TRUE
  )
```

<br>

# Total ion Chromatograms (TICs)

```{r tics, message=FALSE, fig.height=9, fig.cap="Total ion chromatogram (TIC) of all analyses by replicate group name."}
ms <- MassSpecData$new(selected_files)
ms$add_replicate_names(anaInfo$group)
ms$add_blank_names(anaInfo$blank)
ms$plot_tic(levels = 1, colorBy = "replicates")
```

<br>

# Data processing

```{r data-process, message=FALSE, results='markup'}
ms$find_features(
  Settings_find_features_openms(
    noiseThrInt = 1000,
    chromSNR = 3,
    chromFWHM = 7,
    mzPPM = 15,
    reEstimateMTSD = TRUE,
    traceTermCriterion = "sample_rate",
    traceTermOutliers = 5,
    minSampleRate = 1,
    minTraceLength = 4,
    maxTraceLength = 70,
    widthFiltering = "fixed",
    minFWHM = 4,
    maxFWHM = 35,
    traceSNRFiltering = TRUE,
    localRTRange = 0,
    localMZRange = 0,
    isotopeFilteringModel = "none",
    MZScoring13C = FALSE,
    useSmoothedInts = FALSE,
    extraOpts = NULL,
    intSearchRTWindow = 3,
    useFFMIntensities = FALSE,
    verbose = FALSE
  )
)

ms$group_features(
  Settings_group_features_openms(
    rtalign = FALSE,
    QT = FALSE,
    maxAlignRT = 8,
    maxAlignMZ = 0.01,
    maxGroupRT = 8,
    maxGroupMZ = 0.01,
    extraOptsRT = NULL,
    extraOptsGroup = NULL,
    verbose = FALSE
  )
)

ms$find_internal_standards(
  Settings_find_internal_standards_StreamFind(
    database = dbis,
    ppm = 8,
    sec = 10
  )
)

ms
```

```{r internal-standards, fig.height=9, fig.cap="Evaluaton of spiked internal standards after feature finding and grouping."}
ms$plot_internal_standards_qc()
```

```{r internal-standards-eic, fig.height=9, fig.cap="Extracted ion chromatogram (EIC) of four spiked internal standards per analysis replicate group.", message=FALSE}
ms$plot_eic(mass = dbis[c(3, 4, 7, 8), c("name", "mass"), with = FALSE], colorBy = "replicates+targets", legendNames = TRUE, ppm = 20)
```


```{r to-patroon, message=FALSE, results='markup'}
fGroups <- ms$as_patRoon_featureGroups()
fGroups
```


<br>

# Implementation in patRoon

## Conditions

- Analyses must have associated blanks
- Features must be group across analyses for correspondence

## Get TICs

```{r get-tics-func, warning=FALSE, message=FALSE}
getTICs <- function(anaInfo) {
  filePaths <- patRoon:::getMzMLOrMzXMLAnalysisPath(anaInfo$analysis, anaInfo$path, mustExist = TRUE)
  # can be applied in parallel but probably not advantageous
  tics <- lapply(filePaths, function(fpath) {
    msf <- mzR::openMSfile(fpath)
    hd <- mzR::header(msf)
    mzR::close(msf)
    hd <- hd[hd$msLevel == 1, ]
    data.table::data.table("rt" = hd$retentionTime, "int" = hd$totIonCurrent)
  })
  names(tics) <- anaInfo$analysis
  tics
}
```

```{r get-tics, warning=FALSE, message=FALSE, results='markup'}
tics <- getTICs(anaInfo)

length(tics)

is(tics)

head(tics[[1]])
```

## Calculate TIC matrix profiles (MPs)

The function uses a retention window (`rtWindow`), in seconds, to estimate the blank level in the proximity of the analysis spectrum. For now, simple average is used to aggregate the TIC MPs calculated for each blank replicate group associated with a given analysis and then to summarize the analysis MPs into one matrix profile (MP) vector. The MP is calculated according to eq. 6 (see below) of 10.1021/acs.analchem.1c00357.

$TIC_{MP} = (\frac{TIC^{matrix}}{TIC^{blank}}) * -1$

```{r calc-mps-func, warning=FALSE, message=FALSE}
calculateTicMps <- function(anaInfo, tics, rtWindow = 10) {
  
  .trimVector <- function(v, a, b) {
    rowSums(mapply(function(a, b) v >= a & v <= b, a = a, b = b)) > 0
  }
  
  blkGroups <- anaInfo$blank
  names(blkGroups) <- anaInfo$analysis
  
  blkAnalyses <- anaInfo$analysis
  names(blkAnalyses) <- anaInfo$blank
  blkAnalyses <- blkAnalyses[anaInfo$group %in% anaInfo$blank]
  
  # can be applied in parallel but probably not advantageous
  anaMpList <- lapply(anaInfo$analysis, function(x, blkGroups, blkAnalyses, tics, rtWindow) {
    
    blkG <- blkGroups[x]
    blkA <- blkAnalyses[names(blkAnalyses) %in% blkG]
    
    ticX <- tics[[x]]
    
    mpListX <- lapply(tics[blkA], function(z, ticX, rtWindow) {
      
      mp <- vapply(seq_len(nrow(ticX)), function(j, z) {
        rt <- ticX$rt[j]
        rtr <- c(rt - rtWindow, rt + rtWindow)
        intB <- mean(z$int[.trimVector(z$rt, rtr[1], rtr[2])])
        # eq. 6 from 10.1021/acs.analchem.1c00357
        (ticX$int[j] / intB) * -1
      }, z = z, 0)
      
      mp
      
    }, ticX = ticX, rtWindow = rtWindow)
    
    ticX$mp <- Reduce(`+`, mpListX) / length(mpListX)
    
    ticX
    
  }, blkGroups = blkGroups, blkAnalyses = blkAnalyses, tics = tics, rtWindow = rtWindow)
  
  names(anaMpList) <- anaInfo$analysis
  
  anaMpList
}
```

```{r calc-mps, warning=FALSE, message=FALSE, fig.height=9, fig.cap="TIC MPs of each analysis"}
ticMps <- calculateTicMps(anaInfo, tics, 5)

fig <- plot_ly()
cl <- StreamFind:::.get_colors(anaInfo$group)
sL <- !duplicated(cl)

for(i in seq_len(nrow(anaInfo))) {
  fig <- fig %>% add_trace(
    x = ticMps[[i]]$rt,
    y = ticMps[[i]]$mp,
    name = names(cl)[i],
    legendgroup = names(cl)[i],
    showlegend = sL[i],
    type = "scatter",
    mode = 'lines',
    line = list(color = cl[i])
  )
}

xaxis <- list(
  linecolor = toRGB("black"),
  linewidth = 2, title = "Retention time / seconds",
  titlefont = list(size = 12, color = "black")
)

yaxis <- list(
  linecolor = toRGB("black"),
  linewidth = 2, title = "Suppression factor",
  titlefont = list(size = 12, color = "black")
)

fig <- fig %>% plotly::layout(xaxis = xaxis, yaxis = yaxis)

fig
```

## Correct intensity of featureGroups 

```{r calc-int-corr, warning=FALSE, message=FALSE}
calculateCorrectedIntensities <- function(dt, anaInfo, ticMps, rtWindow) {
  
  blkGroups <- anaInfo$blank
  names(blkGroups) <- anaInfo$analysis
  
  blkAnalyses <- anaInfo$analysis
  names(blkAnalyses) <- anaInfo$blank
  blkAnalyses <- blkAnalyses[anaInfo$group %in% anaInfo$blank]
  
  out <- data.table(
    "feature" = dt$feature,
    "group" = dt$group,
    "analysis" = dt$analysis,
    "rt" = dt$rt,
    "intensity" = dt$intensity,
    "scale" = NA_real_,
    "mp" = NA_real_,
    "corrected" = NA_real_
  )
  
  for (i in seq_len(nrow(out))) {
    mp <- ticMps[[out$analysis[i]]]
    
    if (is.null(rtWindow)) rtWindow <- (out$rtmax[i] - out$rtmin[i]) / 4
    
    sel <- (mp$rt >= (out$rt[i] - rtWindow)) & (mp$rt <= (out$rt[i] + rtWindow))
    
    mp <- mp[sel, ]
    
    bInt <- 0
  
    for (j in seq_len(length(blkAnalyses))) {
      
      bMp <- ticMps[[blkAnalyses[j]]]
      
      sel <- (bMp$rt >= (out$rt[i] - rtWindow)) & (bMp$rt <= (out$rt[i] + rtWindow))
      
      bMp <- bMp[sel, ]
      
      bInt <- bInt + mean(bMp$int)
    }
    
    bInt <- bInt / length(blkAnalyses)
    
    selBlkInts <- (out$analysis %in% blkAnalyses) & (out$group %in% out$group[i])
    
    if (!any(selBlkInts)) {
      warning("Feature", out$feature[i], " from analysis ", out$analysis[i], " does not have blank representation!")
      next
    }
    
    #based on eq. 4 from 10.1021/acs.analchem.1c00357
    out$scale[i] <- ((mean(out$intensity[selBlkInts]) / out$intensity[i]) - 1) * -1
    
    #based on eq. 7 from 10.1021/acs.analchem.1c00357
    out$mp[i] <- ((mean(mp$int) / bInt) * -1) * out$scale[i] / mean(mp$mp)
    
    #based on eq. 8 from 10.1021/acs.analchem.1c00357
    out$corrected[i] <- out$intensity[i] * ((1 - out$mp[i] + 1) - 1)
  }
  
  out
}
```

```{r calc-ints, warning=FALSE, message=FALSE, fig.height=9, fig.cap="Corrected instensity of internal standards (dashed lines are corrected intensities)."}
# testing with the spiked internal standards
istd <- ms$get_internal_standards(average = FALSE)
istd <- istd[, c("group", "name"), with = TRUE]

dt <- ms$get_features(features = istd)

corrInts <- calculateCorrectedIntensities(dt, anaInfo, ticMps, rtWindow = 4)

g_names <- dt$name
names(g_names) <- dt$group

corrInts$name <- g_names[corrInts$group]

fig <- plot_ly(corrInts, x = corrInts$analysis)
grps <- unique(corrInts$name)
colors <- StreamFind:::.get_colors(grps)

for (g in grps) {
  df <- corrInts[corrInts$name == g, ]

  fig <- fig %>% add_trace(df,
    x = df$analysis,
    y = df$intensity,
    type = "scatter", mode = "lines",
    line = list(width = 1, color = colors[g]),
    connectgaps = FALSE,
    name = g,
    legendgroup = g,
    showlegend = TRUE
  )

  fig <- fig %>% add_trace(df,
    x = df$analysis,
    y = df$corrected,
    type = "scatter", mode = "lines",
    line = list(width = 1, color = colors[g], dash = 'dash'),
    connectgaps = FALSE,
    name = g,
    legendgroup = g,
    showlegend = FALSE
  )
}

xaxis <- list(
  linecolor = toRGB("black"),
  linewidth = 2, title = "Analysis",
  titlefont = list(size = 12, color = "black")
)

yaxis <- list(
  linecolor = toRGB("black"),
  linewidth = 2, title = "Intensity / counts",
  titlefont = list(size = 12, color = "black")
)

fig <- fig %>% plotly::layout(xaxis = xaxis, yaxis = yaxis)

fig
```


<br>
